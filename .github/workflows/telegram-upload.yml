name: Telegram Uploader

on:
  workflow_dispatch:
    inputs:
      download_url:
        description: 'Ø±Ø§Ø¨Ø· ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ'
        required: true
        type: string
      logo_url:
        description: 'Ø±Ø§Ø¨Ø· Ø§Ù„Ù„ÙˆØ¬Ùˆ'
        required: true
        type: string
      channel_username:
        description: 'Ø±Ø§Ø¨Ø· Ø§Ù„Ù‚Ù†Ø§Ø©'
        required: true
        type: string
      content_type:
        description: 'Ù†ÙˆØ¹ Ø§Ù„Ù…Ø­ØªÙˆÙ‰'
        required: true
        type: choice
        options:
          - movie
          - series
        default: 'movie'
      rename_file:
        description: 'Ø¥Ø¹Ø§Ø¯Ø© ØªØ³Ù…ÙŠØ© Ø§Ù„Ù…Ù„Ù'
        required: false
        type: boolean
        default: false
      new_name:
        description: 'Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯'
        required: false
        type: string
      series_links:
        description: 'Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø­Ù„Ù‚Ø§Øª'
        required: false
        type: string

jobs:
  upload:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install telethon aiohttp requests
          sudo apt-get update
          sudo apt-get install -y ffmpeg

      - name: Create Simple Uploader Script
        run: |
          cat > simple_uploader.py << 'EOF'
          #!/usr/bin/env python3
          import os
          import sys
          import asyncio
          import aiohttp
          from telethon import TelegramClient
          from telethon.sessions import StringSession
          import subprocess
          import re

          print("ðŸš€ SIMPLE UPLOADER STARTED")

          async def main():
              print("ðŸŽ¯ MAIN FUNCTION STARTED")
              
              # Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
              download_url = os.getenv('INPUT_DOWNLOAD_URL')
              logo_url = os.getenv('INPUT_LOGO_URL') 
              channel_username = os.getenv('INPUT_CHANNEL_USERNAME')
              content_type = os.getenv('INPUT_CONTENT_TYPE', 'movie')
              rename_option = os.getenv('INPUT_RENAME_FILE', 'false').lower() == 'true'
              new_name = os.getenv('INPUT_NEW_NAME', '')
              
              print("ðŸ“‹ INPUTS:")
              print(f"   VIDEO: {download_url}")
              print(f"   LOGO: {logo_url}")
              print(f"   CHANNEL: {channel_username}")
              print(f"   TYPE: {content_type}")
              print(f"   RENAME: {rename_option}")
              print(f"   NEW NAME: {new_name}")
              
              try:
                  # 1. Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨ØªÙ„ÙŠØ¬Ø±Ø§Ù…
                  print("ðŸ”Œ STEP 1: Connecting to Telegram...")
                  client = TelegramClient(
                      StringSession(os.getenv('TELEGRAM_SESSION_STRING')),
                      int(os.getenv('TELEGRAM_API_ID')),
                      os.getenv('TELEGRAM_API_HASH')
                  )
                  await client.start()
                  me = await client.get_me()
                  print(f"âœ… Connected as: {me.first_name}")
                  
                  # 2. Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù‚Ù†Ø§Ø© Ø¨Ø·Ø±Ù‚ Ù…ØªØ¹Ø¯Ø¯Ø©
                  print("ðŸ” STEP 2: Finding channel...")
                  entity = None
                  
                  # Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© 1: Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯Ø¹ÙˆØ©
                  if 't.me/+' in channel_username:
                      try:
                          print("   ðŸ”‘ Trying invite link...")
                          invite_hash = channel_username.split('t.me/+')[-1]
                          result = await client.import_chat_invite(invite_hash)
                          if result and hasattr(result, 'chats') and result.chats:
                              entity = await client.get_entity(result.chats[0].id)
                              print(f"âœ… Channel found via invite: {getattr(entity, 'title', 'Unknown')}")
                      except Exception as e:
                          print(f"   âš ï¸ Invite failed: {e}")
                  
                  # Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© 2: Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø§Øª
                  if not entity:
                      try:
                          print("   ðŸ”Ž Searching in dialogs...")
                          async for dialog in client.iter_dialogs(limit=20):
                              if hasattr(dialog.entity, 'id'):
                                  # ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù‚Ù†Ø§Ø© ÙÙŠ Ø§Ù„Ø¯Ø±Ø¯Ø´Ø§Øª
                                  print(f"   ðŸ’¬ Checking: {dialog.name} (ID: {dialog.id})")
                                  if str(dialog.id) in ['-1001548535280', '-1001577518279']:  # Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø¹Ø±ÙˆÙØ©
                                      entity = dialog.entity
                                      print(f"âœ… Known channel found: {dialog.name}")
                                      break
                      except Exception as e:
                          print(f"   âš ï¸ Dialog search failed: {e}")
                  
                  # Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© 3: Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¹Ø±Ù Ù‚Ù†Ø§Ø© Ù…Ø¨Ø§Ø´Ø±
                  if not entity:
                      try:
                          print("   ðŸ”¢ Trying direct channel ID...")
                          # Ø¬Ø±Ø¨ Ø§Ù„Ù‚Ù†ÙˆØ§Øª Ø§Ù„Ù…Ø¹Ø±ÙˆÙØ©
                          known_channels = [-1001548535280, -1001577518279]
                          for channel_id in known_channels:
                              try:
                                  entity = await client.get_entity(channel_id)
                                  print(f"âœ… Direct channel found: {getattr(entity, 'title', 'Unknown')}")
                                  break
                              except:
                                  continue
                      except Exception as e:
                          print(f"   âš ï¸ Direct ID failed: {e}")
                  
                  if not entity:
                      print("âŒ Channel not found - Available channels:")
                      try:
                          async for dialog in client.iter_dialogs(limit=10):
                              if hasattr(dialog.entity, 'broadcast') and dialog.entity.broadcast:
                                  print(f"   ðŸ“¢ {dialog.name} (ID: {dialog.id})")
                      except:
                          pass
                      return False
                  
                  print(f"âœ… Target channel: {getattr(entity, 'title', 'Unknown')}")
                  
                  # 3. ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
                  print("ðŸ“¥ STEP 3: Downloading video...")
                  video_content = None
                  async with aiohttp.ClientSession() as session:
                      async with session.get(download_url, ssl=False) as response:
                          if response.status == 200:
                              video_content = await response.read()
                              print(f"âœ… Video downloaded: {len(video_content)} bytes")
                          else:
                              print(f"âŒ Video download failed: {response.status}")
                              return False
                  
                  # 4. ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù„ÙˆØ¬Ùˆ
                  print("ðŸ“¥ STEP 4: Downloading logo...")
                  logo_content = None
                  async with aiohttp.ClientSession() as session:
                      async with session.get(logo_url, ssl=False) as response:
                          if response.status == 200:
                              logo_content = await response.read()
                              print(f"âœ… Logo downloaded: {len(logo_content)} bytes")
                          else:
                              print(f"âŒ Logo download failed: {response.status}")
                              return False
                  
                  # 5. Ø­ÙØ¸ Ø§Ù„Ù…Ù„ÙØ§Øª Ù…Ø¤Ù‚ØªØ§Ù‹
                  print("ðŸ’¾ STEP 5: Saving files...")
                  with open("video.mp4", "wb") as f:
                      f.write(video_content)
                  with open("logo.png", "wb") as f:
                      f.write(logo_content)
                  
                  # 6. Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù„ÙˆØ¬Ùˆ
                  print("ðŸŽ¨ STEP 6: Adding logo...")
                  result = subprocess.run([
                      'ffmpeg', '-i', 'video.mp4', '-i', 'logo.png',
                      '-filter_complex', '[1]scale=150:150[logo];[0][logo]overlay=10:10',
                      '-c:a', 'copy', 'final_video.mp4', '-y'
                  ], capture_output=True, text=True)
                  
                  if result.returncode != 0:
                      print("âŒ Logo addition failed")
                      final_video = "video.mp4"
                  else:
                      print("âœ… Logo added successfully")
                      final_video = "final_video.mp4"
                  
                  # 7. Ø§Ù„Ø±ÙØ¹
                  print("ðŸ“¤ STEP 7: Uploading...")
                  caption = f"ðŸŽ¬ **{new_name}**\n\n" if new_name else "ðŸŽ¬ **ÙÙŠÙ„Ù… Ø¬Ø¯ÙŠØ¯**\n\n"
                  
                  # Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©
                  print("   ðŸ–¼ï¸ Uploading image...")
                  with open("logo.png", "rb") as f:
                      uploaded_photo = await client.upload_file(f)
                  
                  # Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ  
                  print("   ðŸŽ¬ Uploading video...")
                  with open(final_video, "rb") as f:
                      uploaded_video = await client.upload_file(f)
                  
                  # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨ÙˆØ³Øª
                  print("   ðŸ“ Sending post...")
                  await client.send_file(entity, [uploaded_photo, uploaded_video], caption=caption)
                  
                  print("âœ… UPLOAD COMPLETED SUCCESSFULLY!")
                  
                  # ØªÙ†Ø¸ÙŠÙ
                  for file in ["video.mp4", "logo.png", "final_video.mp4"]:
                      try:
                          os.remove(file)
                      except:
                          pass
                          
                  await client.disconnect()
                  return True
                  
              except Exception as e:
                  print(f"âŒ ERROR: {e}")
                  import traceback
                  traceback.print_exc()
                  return False

          if __name__ == "__main__":
              print("â­ SCRIPT STARTING")
              try:
                  success = asyncio.run(main())
                  print(f"â­ SCRIPT COMPLETED: {'SUCCESS' if success else 'FAILED'}")
                  sys.exit(0 if success else 1)
              except Exception as e:
                  print(f"ðŸ’¥ SCRIPT CRASHED: {e}")
                  sys.exit(1)
          EOF

      - name: Run Simple Uploader
        env:
          TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
          TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
          TELEGRAM_SESSION_STRING: ${{ secrets.TELEGRAM_SESSION_STRING }}
          INPUT_DOWNLOAD_URL: ${{ github.event.inputs.download_url }}
          INPUT_LOGO_URL: ${{ github.event.inputs.logo_url }}
          INPUT_CHANNEL_USERNAME: ${{ github.event.inputs.channel_username }}
          INPUT_CONTENT_TYPE: ${{ github.event.inputs.content_type }}
          INPUT_RENAME_FILE: ${{ github.event.inputs.rename_file }}
          INPUT_NEW_NAME: ${{ github.event.inputs.new_name }}
        run: |
          echo "=== ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ù…Ø¨Ø³Ø·Ø© ==="
          python simple_uploader.py
